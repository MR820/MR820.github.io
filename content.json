[{"title":"go问题排查","date":"2021-07-04T06:40:42.000Z","path":"2021/07/04/go问题排查/","comments":true,"excerpt":"trace如何观察go gc GODEBUG=gctrace=1 12go build -o mainGODEBUGE=gctrace=1 ./main","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"问题排查","slug":"问题排查","permalink":"https://note.wyxxt.org.cn/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}]},{"title":"go优化","date":"2021-07-03T07:32:20.000Z","path":"2021/07/03/go优化/","comments":true,"excerpt":"","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"优化","slug":"优化","permalink":"https://note.wyxxt.org.cn/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"go并发编程","date":"2021-07-03T07:21:08.000Z","path":"2021/07/03/go并发编程/","comments":true,"excerpt":"goroutine调度GMP G代表一个goroutine对象，每次go调用的时候，都会创建一个G对象 M代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行 P代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://note.wyxxt.org.cn/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"go语言unsafe","date":"2021-07-03T04:20:50.000Z","path":"2021/07/03/go语言unsafe/","comments":true,"excerpt":"","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"unsafe","slug":"unsafe","permalink":"https://note.wyxxt.org.cn/tags/unsafe/"}]},{"title":"go语言cgo","date":"2021-07-03T04:20:14.000Z","path":"2021/07/03/go语言cgo/","comments":true,"excerpt":"","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"cgo","slug":"cgo","permalink":"https://note.wyxxt.org.cn/tags/cgo/"}]},{"title":"go语言context","date":"2021-07-03T04:19:30.000Z","path":"2021/07/03/go语言context/","comments":true,"excerpt":"","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"context","slug":"context","permalink":"https://note.wyxxt.org.cn/tags/context/"}]},{"title":"go反射","date":"2021-07-01T10:35:04.000Z","path":"2021/07/01/go反射/","comments":true,"excerpt":"反射在reflect包中，主要通过Typeof()和Valueof()两个方法来实现反射。两个方法相互结合，能够反射出被反射函数的全部信息。","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://note.wyxxt.org.cn/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"go内存管理","date":"2021-07-01T03:30:11.000Z","path":"2021/07/01/go内存管理/","comments":true,"excerpt":"Go GC 20 问 Demystifying memory management in modern programming languages Goroutine调度实例简要分析 可视化Go内存管理 指针go语言没有指针运算 &amp; 取地址符 *指针可以指向任何类型 以下面代码为例，指针指向int类型","categories":[{"name":"go","slug":"go","permalink":"https://note.wyxxt.org.cn/categories/go/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://note.wyxxt.org.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"GC","slug":"GC","permalink":"https://note.wyxxt.org.cn/tags/GC/"}]}]